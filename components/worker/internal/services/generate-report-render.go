// Copyright (c) 2026 Lerian Studio. All rights reserved.
// Use of this source code is governed by the Elastic License 2.0
// that can be found in the LICENSE file.

package services

import (
	"context"
	"fmt"
	"os"
	"strings"

	"github.com/LerianStudio/reporter/pkg/pongo"

	"github.com/LerianStudio/lib-commons/v2/commons/log"
	libOtel "github.com/LerianStudio/lib-commons/v2/commons/opentelemetry"

	// otel/trace is used for trace.Tracer and trace.Span parameter types
	"go.opentelemetry.io/otel/trace"
)

// loadTemplate loads template file from SeaweedFS.
func (uc *UseCase) loadTemplate(ctx context.Context, tracer trace.Tracer, message GenerateReportMessage, span *trace.Span, logger log.Logger) ([]byte, error) {
	ctx, spanTemplate := tracer.Start(ctx, "service.report.get_template")
	defer spanTemplate.End()

	fileBytes, err := uc.TemplateSeaweedFS.Get(ctx, message.TemplateID.String())
	if err != nil {
		if errUpdate := uc.updateReportWithErrors(ctx, message.ReportID, err.Error()); errUpdate != nil {
			libOtel.HandleSpanError(span, "Error to update report status with error.", errUpdate)
			logger.Errorf("Error update report status with error: %s", errUpdate.Error())

			return nil, errUpdate
		}

		libOtel.HandleSpanError(&spanTemplate, "Error getting file from template bucket.", err)
		logger.Errorf("Error getting file from template bucket: %s", err.Error())

		return nil, err
	}

	logger.Infof("Template loaded successfully (size: %d bytes)", len(fileBytes))

	return fileBytes, nil
}

// renderTemplate renders the template with data from external sources.
func (uc *UseCase) renderTemplate(ctx context.Context, tracer trace.Tracer, templateBytes []byte, result map[string]map[string][]map[string]any, message GenerateReportMessage, span *trace.Span, logger log.Logger) (string, error) {
	ctx, spanRender := tracer.Start(ctx, "service.report.render_template")
	defer spanRender.End()

	renderer := pongo.NewTemplateRenderer()

	out, err := renderer.RenderFromBytes(ctx, templateBytes, result, logger)
	if err != nil {
		if errUpdate := uc.updateReportWithErrors(ctx, message.ReportID, err.Error()); errUpdate != nil {
			libOtel.HandleSpanError(span, "Error to update report status with error.", errUpdate)
			logger.Errorf("Error update report status with error: %s", errUpdate.Error())

			return "", errUpdate
		}

		libOtel.HandleSpanError(&spanRender, "Error rendering template.", err)
		logger.Errorf("Error rendering template: %s", err.Error())

		return "", err
	}

	return out, nil
}

// convertToPDFIfNeeded converts HTML to PDF if output format is PDF.
func (uc *UseCase) convertToPDFIfNeeded(ctx context.Context, tracer trace.Tracer, message GenerateReportMessage, htmlOutput string, span *trace.Span, logger log.Logger) (string, error) {
	if strings.ToLower(message.OutputFormat) != "pdf" {
		return htmlOutput, nil
	}

	_, spanPDF := tracer.Start(ctx, "service.report.convert_to_pdf")
	defer spanPDF.End()

	logger.Infof("Converting HTML to PDF for report %s (HTML size: %d bytes)", message.ReportID, len(htmlOutput))

	pdfBytes, err := uc.convertHTMLToPDF(htmlOutput, logger)
	if err != nil {
		if errUpdate := uc.updateReportWithErrors(ctx, message.ReportID, err.Error()); errUpdate != nil {
			libOtel.HandleSpanError(span, "Error to update report status with error.", errUpdate)
			logger.Errorf("Error update report status with error: %s", errUpdate.Error())

			return "", errUpdate
		}

		libOtel.HandleSpanError(&spanPDF, "Error converting HTML to PDF.", err)
		logger.Errorf("Error converting HTML to PDF: %s", err.Error())

		return "", err
	}

	logger.Infof("PDF generated successfully (PDF size: %d bytes)", len(pdfBytes))

	return string(pdfBytes), nil
}

// convertHTMLToPDF converts HTML content to PDF using Chrome headless via PDF pool.
func (uc *UseCase) convertHTMLToPDF(htmlContent string, logger log.Logger) ([]byte, error) {
	tmpFile, err := os.CreateTemp("", "pdf-*.pdf")
	if err != nil {
		logger.Errorf("Failed to create temporary PDF file: %v", err)
		return nil, fmt.Errorf("failed to create temporary PDF file: %w", err)
	}

	tmpFileName := tmpFile.Name()
	if closeErr := tmpFile.Close(); closeErr != nil {
		logger.Warnf("Failed to close temporary file %s: %v", tmpFileName, closeErr)
	}

	defer func() {
		if removeErr := os.Remove(tmpFileName); removeErr != nil {
			logger.Warnf("Failed to remove temporary PDF file %s: %v", tmpFileName, removeErr)
		}
	}()

	err = uc.PdfPool.Submit(htmlContent, tmpFileName)
	if err != nil {
		logger.Errorf("Failed to generate PDF from HTML: %v", err)
		return nil, fmt.Errorf("failed to generate PDF from HTML: %w", err)
	}

	// Read generated PDF file - tmpFileName is safe as it comes from os.CreateTemp
	// #nosec G304 -- tmpFileName is generated by os.CreateTemp and is safe
	pdfBytes, err := os.ReadFile(tmpFileName)
	if err != nil {
		logger.Errorf("Failed to read generated PDF: %v", err)
		return nil, fmt.Errorf("failed to read generated PDF: %w", err)
	}

	return pdfBytes, nil
}
